<!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link rel="stylesheet" href="/ZChen/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="/ZChen/css/main.css?v=7.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/ZChen/images/apple-touch-icon-next.png?v=7.2.0"><link rel="icon" type="image/png" sizes="32x32" href="/ZChen/images/favicon-32x32-next.png?v=7.2.0"><link rel="icon" type="image/png" sizes="16x16" href="/ZChen/images/favicon-16x16-next.png?v=7.2.0"><link rel="mask-icon" href="/ZChen/images/logo.svg?v=7.2.0" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/ZChen/",scheme:"Mist",version:"7.2.0",sidebar:{position:"left",display:"post",offset:12,onmobile:!1,dimmer:!1},back2top:!0,back2top_sidebar:!1,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="这是一个用于记录我个人学习历程的小站。"><meta property="og:type" content="website"><meta property="og:title" content="ZChen&#39;s Blog"><meta property="og:url" content="http://yoursite.com/index.html"><meta property="og:site_name" content="ZChen&#39;s Blog"><meta property="og:description" content="这是一个用于记录我个人学习历程的小站。"><meta property="og:locale" content="zh-CN"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ZChen&#39;s Blog"><meta name="twitter:description" content="这是一个用于记录我个人学习历程的小站。"><link rel="canonical" href="http://yoursite.com/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>ZChen's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/ZChen/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ZChen's Blog</span><span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/ZChen/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/ZChen/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/ZChen/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/ZChen/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/ZChen/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/ZChen/category/字节跳动-实习经历/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZChen"><meta itemprop="description" content="这是一个用于记录我个人学习历程的小站。"><meta itemprop="image" content="/ZChen/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZChen's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/ZChen/category/字节跳动-实习经历/" class="post-title-link" itemprop="url">字节跳动 实习经历</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-15 17:23:56 / 修改时间：20:11:54" itemprop="dateCreated datePublished" datetime="2019-10-15T17:23:56+08:00">2019-10-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/ZChen/categories/杂记/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a></span></span><br></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在2019年6月末，我作为一名后端开发实习生，入职了字节跳动 今日头条财经部门，直到同年9月末离职。</p><p>我认为这是一段很有意义的实习，所以在这里记录一下实习过程，以及实习感悟。</p><p>以下内容和感悟，只是我在实习后的一些所思所想，有很多局限性，因此可能会有很多比较幼稚的想法。</p><h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><p>在实习的这三个月，我主要完成的是一个信息展示的项目，似乎不能透露具体细节，所以我在这里只说一下研发流程。这个研发流程可能不同的公司不同的组会不太一样，但是总体的思路应该是相同的。</p><p>首先在接到一个项目需求后，会根据项目的需求，根据UI和产品经理提供的图和文档，编写接口文档（提供给前端）。再根据接口文档写这一期项目的设计文档。设计文档主要包含：接口的逻辑、数据库和缓存的设计、task的逻辑和作用等。在写接口文档和设计文档的过程中，会逐渐了解项目，并且会分配具体每个人要完成的接口和task，每个人写自己需要完成那部分的设计。</p><p>在写设计文档的过程中，可能就开始开发了，首先搭好项目开发的脚手架，然后根据项目的不同，修改一些配置，添加项目所用表的sql。然后就可以开始进行业务逻辑的开发了。</p><p>在开始开发之前，还需要根据接口文档写提供给前端的mock。在我实习过程中，前端的mock是后端来提供的，但是这项工作似乎根据项目组和公司的不同，很多是前端自己来写的。</p><p>在实际开发过程中，肯定会发现一些在设计过程中没有发现的问题，然后再调整实现的逻辑，并不断对齐设计文档。</p><p>开发和写ut一般是同时进行的，但是一般在开发结束后，ut覆盖率是无法达标的，而且可能会存在很多问题，需要后面做单独的处理。</p><p>开发基本完成后，就会开始联调。联调的环境通常跟开发和ut的环境是不同的。总的来说，一般需要3套环境，开发环境，联调环境，线上环境。</p><p>联调完成后，会有QA（测试）人员进行测试，并反馈BUG。<br>根据我的观察，开发、联调、测试虽然有一个比较明确的时间点，但是在实际操作过程中，其实这个时间是很模糊的，可能前后端开发还差很多呢，就开始部署联调环境开始联调了。<br>然后，两边的开发和联调尚未结束时，就开始进行测试了。所以有时候，说是反馈BUG，可能只是这部分还没写完。这种情况不知道是互联网公司的常态，还是只有进度比较紧的情况下才会发生。</p><p>测试完成而且PM（产品经理）验收后，就可以上线了。但是其实这时候这个项目并不是完全稳定了，因为，项目会有很多开发人员不清楚的具体问题（比如，数据的范围，数据的量等等）。<br>这些问题需要产品上线后，持续观察才可以确定。所以，一个项目是需要设置很多报警和监控的，而且开发人员在项目刚上线的时候，也需要持续关注项目。<br>上线后，发现问题与预期不相符的时候，就需要进行优化了。</p><h1 id="技术感悟"><a href="#技术感悟" class="headerlink" title="技术感悟"></a>技术感悟</h1><p>在实习过程中，我学习到的东西主要是项目设计的相关知识，以及大厂的技术栈和真正的项目开发流程等知识。<br>至于单纯的技术方面，其实并没有学习到很多内容，或者说本身完成业务逻辑的开发，其实并不需要很强的技术能力。</p><p>我认为在业务逻辑的后端开发中，比较重要的几点是：</p><ol><li>对于中间件的了解，包括Mysql，redis，Kafka等。可能不需要完全理解这些中间件的内部数据结构，构建索引的方式等，但是至少要知道大部分使用方式等。</li><li>编程语言和编程基本功。如果对编程语言了解的不好，或者编程基本功比较差，虽然可能仍能实现业务的逻辑，但是实现方式会比较丑陋。<br>而且比较重要一点是，可能阅读其他人的代码或者一些第三方库会有困难。</li><li>项目设计的能力。这个可能比较考验经验和技术栈的深度。应当使用什么样的策略，怎样设计task，怎样设计接口的实现逻辑等。</li></ol><p>总而言之，在我实习过程中，我认为进行业务逻辑的开发还是比较容易的，这可能跟mentor给我分配的任务相对容易有关系，但是我认为在我研究生毕业后，或者工作一两年后，进行通常的业务逻辑的开发必然不再是一件有挑战的事情。</p><p>不过，如果再加上高访问量，高并发等场景，可能还是比较有调整的一件事。</p><p>总而言之，我比较在乎的一件事是，在未来工作多年后，作为一名后端开发人员，如何最大的实现自己的价值，如何能把自己的技术能力最大的体现出来呢。如果在工作10年后，自己在做的事情和刚工作一两年时做的事情差不多，是我所不能接受的。但是在后端开发这里，似乎也是不可避免的。</p><p>所以是否后端开发人员，尤其是进行业务逻辑开发的人员，在技术成长到一定程度后，后续的成长就需要靠对业务的理解和领导能力等技术无关的方面了？这个问题我现在还无法解答。</p><h1 id="氛围感受"><a href="#氛围感受" class="headerlink" title="氛围感受"></a>氛围感受</h1><p>总体来说，字节跳动的氛围我还是很喜欢的，有“创业精神”，也就是同事之间比较坦诚清晰，而且各种事情办理起来还是很方便的，没有在学校办事的官僚气息。<br>而且公司会定期有，技术分享会，也会鼓励员工写博客、做分享、做专利等。感觉字节跳动还是一个非常重视技术的公司。</p><p>头条实行的加班政策是大小周，正式员工加班的天有加班费，我们实习生也会多拿一天钱，对于没啥事的学生而言还是不错的。<br>另外就是，工作时间，我一般在上午10点半之前到公司，然后，晚上回去的时间不定，比较早的时候，就是8点走，晚的时候会到10点，通常是9点之前，大概8点50左右。<br>我的感受是，不算周五、加班的周日还有活动日等特殊回去早的时间，平均下班大概是在9点。<br>下班时间主要是看近期的工作量和会议的安排，如果晚上有code review等会，自然会回去的晚，如果近期没啥开发任务，8点就可以溜了。</p><p>还有我比较重视的一点，就是技术的成长。作为一名从没有互联网工作经历的实习生，在实习过程中，我自然学到了很多。<br>但是我也在思考，如果是一名正式员工，我需要如何增长我的技术力呢。<br>毕竟，项目的开发通常使用的技术栈，都是你熟悉的，你进行的设计，也都是你所了解的。<br>所以在我看来，在日常工作中，是很少有技术能力的增长的，但是可以增长开发的经验，能够处理更多的问题。</p><p>因此，我认为，在工作后，如果想要持续的提升技术能力，就需要自己不断的主动学习，多看项目，或者参与一些开源项目。<br>而做这些的时间，除了从休息时间中挤出来，还需要在上班过程中进行。<br>毕竟在很多开发任务不紧的时候，在公司其实是没事可做的，待在公司只是为了做到oncall，所以这些时间就可以用来主动学习提升技术。<br>这还是很需要毅力和自制力的。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/ZChen/category/【golang】Go汇编入门2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZChen"><meta itemprop="description" content="这是一个用于记录我个人学习历程的小站。"><meta itemprop="image" content="/ZChen/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZChen's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/ZChen/category/【golang】Go汇编入门2/" class="post-title-link" itemprop="url">【golang】Go汇编入门2</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-09-11 15:34:54" itemprop="dateCreated datePublished" datetime="2019-09-11T15:34:54+08:00">2019-09-11</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-13 15:17:27" itemprop="dateModified" datetime="2019-10-13T15:17:27+08:00">2019-10-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/ZChen/categories/后端/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span></span><br></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是<code>Go汇编入门</code>的第二篇文章，也是计划中的最后一篇。第一篇的地址：<a href="../ZChen-blog.github.io/category/【golang】Go汇编入门1/">【golang】Go汇编入门1</a>。</p><p>这一章中，将会用一个go汇编入门常用的样例程序，来进一步了解Go汇编。</p><h1 id="样例程序"><a href="#样例程序" class="headerlink" title="样例程序"></a>样例程序</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//go:noinline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int32</span>)</span> <span class="params">(<span class="keyword">int32</span>, <span class="keyword">bool</span>)</span></span> &#123; <span class="keyword">return</span> a + b, <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123; add(<span class="number">10</span>, <span class="number">32</span>) &#125;</span><br></pre></td></tr></table></figure><p><code>//go:noinline</code>是编译器指令，不可省略（而且甚至<code>//</code>和<code>go</code>中间不能有空格）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> go version</span><br><span class="line">go version go1.12.6 darwin/amd64</span><br><span class="line"><span class="meta">$</span> GOOS=linux GOARCH=amd64 go tool compile -S main.go &gt; main.s</span><br></pre></td></tr></table></figure><p>golang交叉编译非常方便，我们这里直接分析Linux下的汇编代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">0x0000  TEXT	    &quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-16</span><br><span class="line">0x0000 	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 	FUNCDATA	$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x0000 	PCDATA	    $2, $0</span><br><span class="line">0x0000 	PCDATA	    $0, $0</span><br><span class="line">0x0000 	MOVL	    &quot;&quot;.b+12(SP), AX</span><br><span class="line">0x0004 	MOVL	    &quot;&quot;.a+8(SP), CX</span><br><span class="line">0x0008 	ADDL	    CX, AX</span><br><span class="line">0x000a 	MOVL	    AX, &quot;&quot;.~r2+16(SP)</span><br><span class="line">0x000e 	MOVB	    $1, &quot;&quot;.~r3+20(SP)</span><br><span class="line">0x0013 	RET</span><br><span class="line"></span><br><span class="line">0x0000 	TEXT	    &quot;&quot;.main(SB), ABIInternal, $24-0</span><br><span class="line">0x0000 	MOVQ	    (TLS), CX</span><br><span class="line">0x0009 	CMPQ	    SP, 16(CX)</span><br><span class="line">0x000d 	JLS	58</span><br><span class="line">0x000f 	SUBQ	    $24, SP</span><br><span class="line">0x0013 	MOVQ	    BP, 16(SP)</span><br><span class="line">0x0018 	LEAQ	    16(SP), BP</span><br><span class="line">0x001d 	FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 	FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 	FUNCDATA	$3, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span><br><span class="line">0x001d 	PCDATA	    $2, $0</span><br><span class="line">0x001d 	PCDATA	    $0, $0</span><br><span class="line">0x001d 	MOVQ	    $137438953482, AX</span><br><span class="line">0x0027 	MOVQ	    AX, (SP)</span><br><span class="line">0x002b 	CALL	    &quot;&quot;.add(SB)</span><br><span class="line">0x0030 	MOVQ	    16(SP), BP</span><br><span class="line">0x0035 	ADDQ	    $24, SP</span><br><span class="line">0x0039 	RET</span><br></pre></td></tr></table></figure><p>以上汇编代码，省略了部分不重要内容。</p><h1 id="Dissecting-quot-add-quot"><a href="#Dissecting-quot-add-quot" class="headerlink" title="Dissecting &quot;add&quot;"></a>Dissecting <code>&quot;add&quot;</code></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0000  TEXT &quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-16</span><br></pre></td></tr></table></figure><ul><li><p>0x0000: 当前指令相对于当前函数的偏移量。</p></li><li><p><code>TEXT &quot;&quot;.add</code>: <code>TEXT</code>指令声明了<code>&quot;&quot;.add</code>是<code>.text</code>段(程序代码在运行期会放在内存的<code>.text</code>段中)的一部分，并表明跟在这个声明后的是函数的函数体。 在链接期，<code>&quot;&quot;</code> 这个空字符会被替换为当前的包名: 也就是说，<code>&quot;&quot;.add</code> 在链接到二进制文件后会变成 <code>main.add</code>。</p></li><li><p><code>(SB)</code>:<code>SB</code>是一个虚拟寄存器，保存了静态基地址(static-base) 指针，即我们程序地址空间的开始地址。换句话来讲，它有一个直接的绝对地址: 是一个全局的函数符号。<code>&quot;&quot;.add(SB)</code>表明我们的符号位于某个固定的相对地址空间起始处的偏移位置 (最终是由链接器计算得到的)，也就是它在链接过后，会成为add函数的地址。</p></li><li><p><code>NOSPLIT</code>: 向编译器表明不应该插入<code>stack-split</code>的用来检查栈需要扩张的前导指令。 在我们 add 函数的这种情况下，编译器自己帮我们插入了这个标记。类似的这一系列指令，具体可看<a href="https://golang.org/doc/asm#directives" target="_blank" rel="noopener">[Official] A Quick Guide to Go’s Assembler</a> ，在这里不做过多介绍。</p></li><li><p><code>$0-16</code>: <code>$0</code>代表即将分配的栈帧大小；而<code>$16</code>指定了调用方传入的参数大小，单位是byte。传入参数大小为16bytes，因为除了两个32位的加数<code>a</code> <code>b</code>，栈中还会保存一个返回地址，在64位系统中，占4bytes。如果NOSPLIT没有被指定，则必须提供参数大小。对于Go原型的汇编函数，go vet会检查参数大小是否正确。</p></li><li><p><code>FUNCDATA</code>: FUNCDATA以及PCDATA指令包含有被垃圾回收所使用的信息；这些指令是被编译器加入的。</p></li><li><p><code>&quot;&quot;.a+8(SP)</code>: Go要求每个参数都通过栈来传递，这部分空间由 caller 在其栈帧(stack frame)上提供。<br>调用其它过程之前，caller 就需要按照参数和返回变量的大小来对应地增长(返回后收缩)栈。<br>Go编译器不会生成任何 PUSH/POP 族的指令: 栈的增长和收缩是通过在栈指针寄存器<code>SP</code>上分别执行减法和加法指令来实现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0000 	MOVL	    &quot;&quot;.b+12(SP), AX</span><br><span class="line">0x0004 	MOVL	    &quot;&quot;.a+8(SP), CX</span><br></pre></td></tr></table></figure><p> 这里之所以是<code>+8</code>和 <code>+12</code>，原因也是栈中最后会压入一个返回的地址。</p></li></ul><h1 id="Dissecting-quot-main-quot"><a href="#Dissecting-quot-main-quot" class="headerlink" title="Dissecting &quot;main&quot;"></a>Dissecting <code>&quot;main&quot;</code></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0x0000 	TEXT	    &quot;&quot;.main(SB), ABIInternal, $24-0</span><br><span class="line">0x0000 	MOVQ	    (TLS), CX</span><br><span class="line">0x0009 	CMPQ	    SP, 16(CX)</span><br><span class="line">0x000d 	JLS	58</span><br><span class="line">0x000f 	SUBQ	    $24, SP</span><br><span class="line">0x0013 	MOVQ	    BP, 16(SP)</span><br><span class="line">0x0018 	LEAQ	    16(SP), BP</span><br><span class="line">0x001d 	FUNCDATA ....</span><br><span class="line">0x001d 	PCDATA	    $2, $0</span><br><span class="line">0x001d 	PCDATA	    $0, $0</span><br><span class="line">0x001d 	MOVQ	    $137438953482, AX</span><br><span class="line">0x0027 	MOVQ	    AX, (SP)</span><br><span class="line">0x002b 	CALL	    &quot;&quot;.add(SB)</span><br><span class="line">0x0030 	MOVQ	    16(SP), BP</span><br><span class="line">0x0035 	ADDQ	    $24, SP</span><br><span class="line">0x0039 	RET</span><br></pre></td></tr></table></figure><ul><li><p><code>SUBQ $24, SP</code>：分配24bytes的栈帧，不用push和pop调整栈的大小，而是直接计算SP寄存器的值。</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x001d 	MOVQ	    $137438953482, AX</span><br><span class="line">0x0027 	MOVQ	    AX, (SP)</span><br></pre></td></tr></table></figure><p><code>137438953482</code>该值表示了10和32两个4bytes值的组合：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> echo 'obase=2;137438953482' | bc</span><br><span class="line">10000000000000000000000000000000001010</span><br><span class="line">\_____/\_____________________________/</span><br><span class="line">   32                             10</span><br></pre></td></tr></table></figure></li><li><p><code>CALL &quot;&quot;.add(SB)</code>：CALL命令不只会跳转，还会将SP寄存器减8（64位 地址大小），而后将此处的地址，即函数返回地址，保存进<code>0(SP)</code>的位置。使用static-base指针的偏移量，来对<code>add</code></p></li><li><p><code>0x0030</code>处指令执行之前的栈情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  |    +-------------------------+ &lt;-- 32(SP)              </span><br><span class="line">  |    |                         |                         </span><br><span class="line">G |    |                         |                         </span><br><span class="line">R |    |                         |                         </span><br><span class="line">O |    | main.main&apos;s saved       |                         </span><br><span class="line">W |    |     frame-pointer (BP)  |                         </span><br><span class="line">S |    |-------------------------| &lt;-- 24(SP)              </span><br><span class="line">  |    |      [alignment]        |                         </span><br><span class="line">D |    | &quot;&quot;.~r3 (bool) = 1/true  | &lt;-- 21(SP)              </span><br><span class="line">O |    |-------------------------| &lt;-- 20(SP)              </span><br><span class="line">W |    |                         |                         </span><br><span class="line">N |    | &quot;&quot;.~r2 (int32) = 42     |                         </span><br><span class="line">W |    |-------------------------| &lt;-- 16(SP)              </span><br><span class="line">A |    |                         |                         </span><br><span class="line">R |    | &quot;&quot;.b (int32) = 32       |                         </span><br><span class="line">D |    |-------------------------| &lt;-- 12(SP)              </span><br><span class="line">S |    |                         |                         </span><br><span class="line">  |    | &quot;&quot;.a (int32) = 10       |                         </span><br><span class="line">  |    |-------------------------| &lt;-- 8(SP)               </span><br><span class="line">  |    |                         |                         </span><br><span class="line">  |    |                         |                         </span><br><span class="line">  |    |                         |                         </span><br><span class="line">\ | /  | return address to       |                         </span><br><span class="line"> \|/   |     main.main + 0x30    |                         </span><br><span class="line">  -    +-------------------------+ &lt;-- 0(SP) (TOP OF STACK)</span><br><span class="line"></span><br><span class="line">(diagram made with https://textik.com)</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://github.com/teh-cmc/go-internals" target="_blank" rel="noopener">go-internals[chapter1]</a></li><li><a href="http://xargin.com/plan9-assembly/" target="_blank" rel="noopener">Go系列文章3:plan9汇编入门</a></li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/ZChen/category/【golang】Go汇编入门1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZChen"><meta itemprop="description" content="这是一个用于记录我个人学习历程的小站。"><meta itemprop="image" content="/ZChen/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZChen's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/ZChen/category/【golang】Go汇编入门1/" class="post-title-link" itemprop="url">【golang】Go汇编入门1</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-09-04 21:02:32" itemprop="dateCreated datePublished" datetime="2019-09-04T21:02:32+08:00">2019-09-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-13 15:17:27" itemprop="dateModified" datetime="2019-10-13T15:17:27+08:00">2019-10-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/ZChen/categories/后端/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span></span><br></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为一些需求，我需要学习golang的runtime和标准库源码。在学习过程中发现，Go编译器生成的汇编代码是一种自创的伪汇编，因此，如果我们想要深入学习go语言的底层实现，必须先要学习Go的汇编。</p><p>Go使用了<a href="https://zh.wikipedia.org/wiki/貝爾實驗室九號計畫" target="_blank" rel="noopener">Plan9</a>汇编，目前Plan9汇编的应用场景，好像也只剩Go了。</p><p>以下内容，整合自（抄自）多篇文章，具体来源见<code>参考</code>。</p><p>阅读本文，需要一定的编译原理和汇编知识。阅读完本文后，可以基本看懂Go生成的汇编，以及Go标准库中的汇编，但是如果想要独自写Go的汇编，还需要进一步看<code>参考</code>中的文章。</p><h1 id="“伪汇编”"><a href="#“伪汇编”" class="headerlink" title="“伪汇编”"></a>“伪汇编”</h1><p>Go 编译器会输出一种抽象可移植的汇编代码，这种汇编并不对应某种真实的硬件架构。之后 Go 的汇编器使用这种伪汇编，为目标硬件生成具体的机器指令。</p><p>多一个额外的伪汇编层，可以方便Go移植到新的架构上（但是还是针对各个体系结构和操作系统撰写了对应的汇编，无法做到 write once, compiled anywhere，这个操作有点看不懂，感觉这样的话加上这层意义不大）。对于Go的伪汇编，可以参照Rob Pike的<em>The Design of the Go Assembler</em>。</p><blockquote><p>The most important thing to know about Go’s assembler is that it is not a direct representation of the underlying machine. Some of the details map precisely to the machine, but some do not. This is because the compiler suite needs no assembler pass in the usual pipeline. Instead, the compiler operates on a kind of semi-abstract instruction set, and instruction selection occurs partly after code generation. The assembler works on the semi-abstract form, so when you see an instruction like MOV what the toolchain actually generates for that operation might not be a move instruction at all, perhaps a clear or load. Or it might correspond exactly to the machine instruction with that name. In general, machine-specific operations tend to appear as themselves, while more general concepts like memory move and subroutine call and return are more abstract. The details vary with architecture, and we apologize for the imprecision; the situation is not well-defined.</p><p>The assembler program is a way to parse a description of that semi-abstract instruction set and turn it into instructions to be input to the linker.</p></blockquote><h1 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h1><ul><li><p>指令名称：基本与AT&amp;T和Intel汇编的指令名称差不多，看见就能懂，操作数的长度用指令后缀表示，而非寄存器前缀。</p></li><li><p>计算指令：前后顺序同AT&amp;T</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADDQ AX, BX  // BX += AX</span><br></pre></td></tr></table></figure></li><li><p>常数使用<code>$num</code>来表示，可以为负数，默认为十进制。</p></li><li><p>栈调整通过对硬件SP寄存器进行计算来实现，golang不使用intel和AT&amp;T汇编提供的push和pop指令。</p></li><li><p>指令集可以参考源代码<a href="https://github.com/golang/arch/blob/master/x86/x86.csv" target="_blank" rel="noopener">arch</a>部分</p></li></ul><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>Plan9可以使用大部分amd64的通用寄存器，且不需要前缀（rax=AX）。除此之外，Go的汇编还引入了4个伪寄存器：</p><blockquote><ul><li><p><code>FP</code>: Frame pointer:arguments and locals.</p><p>使用形如<code>symbol+offset(FP)</code>的方式，引用函数的输入参数，例如：<code>arg0+0(FP)</code>，使用<code>FP</code>必须加symbol，否则无法通过编译。symbol为参数名，除增加代码可读性外，没有实际用处。</p></li><li><p><code>PC</code>: Program counter:jumps and branches.</p></li><li><p><code>SB</code>: Static base pointer:global symbols.</p><p>全局静态基指针，一般用来声明函数或全局变量。</p></li><li><p><code>SP</code>: Stack pointer:top of stack.</p><p>伪寄存器SP指向当前栈帧的局部变量的开始位置。<code>symbol-offset(SP)</code>表示引用函数的局部变量。offset的范围为[-framesize, 0)，加入局部变量都是8字节，那么第一个局部变量可用<code>a-8(SP)</code>来表示。该symbol同上，无实意。</p></li></ul></blockquote><p>有以下需要注意的几点：</p><ol><li><p>除伪寄存器SP外，还有一个真实的硬件寄存器SP，区分方法，只需要看前面是否有symbol，有symbol为伪SP；反之，单独的<code>offset(SP)</code>为硬件SP。</p></li><li><p>在<code>go tool objdump/go tool compile -S</code>输出的代码中，是没有伪SP和伪FP的。这两个伪寄存器只出现在手写代码中或者官方库。</p></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://xargin.com/plan9-assembly/" target="_blank" rel="noopener">Go 系列文章3 ：plan9 汇编入门</a></li><li><a href="https://chai2010.cn/advanced-go-programming-book/ch3-asm/ch3-02-arch.html" target="_blank" rel="noopener">Go语言高级编程-汇编</a></li><li><a href="http://www.huamo.online/2019/06/25/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6goroutine%E6%A0%88/" target="_blank" rel="noopener">深入研究goroutine栈</a></li><li><a href="http://xargin.com/go-and-plan9-asm/#pseudo-assembly" target="_blank" rel="noopener">[译]go和plan9汇编</a></li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/ZChen/category/【golang】理解interface/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZChen"><meta itemprop="description" content="这是一个用于记录我个人学习历程的小站。"><meta itemprop="image" content="/ZChen/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZChen's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/ZChen/category/【golang】理解interface/" class="post-title-link" itemprop="url">【golang】理解interface</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-15 10:20:47" itemprop="dateCreated datePublished" datetime="2019-08-15T10:20:47+08:00">2019-08-15</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-13 15:17:27" itemprop="dateModified" datetime="2019-10-13T15:17:27+08:00">2019-10-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/ZChen/categories/后端/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span></span><br></div></header><div class="post-body" itemprop="articleBody"><h1 id="一、interface基本概念"><a href="#一、interface基本概念" class="headerlink" title="一、interface基本概念"></a>一、interface基本概念</h1><blockquote><p>In object-oriented programming, a protocol or interface is a common means for unrelated objects to communicate with each other. — wikipedia</p></blockquote><p>interface可以理解为一种在无相互依赖的对象中沟通的协议。golang中interface是一组method的组合，可以形象的称为duck-type programming（walk like a duck,talk like a duck…）。</p><p>golang中的类型分为concrete types和abstract types，abstract types就是interfaces。concrete types包含两样东西：1. 描述内存格式 2. 定义通过method附加到数据的行为。abstract types同样包含两样东西：1. 描述行为（只是描述，而非定义） 2. 定义一个methods的集合，但不定义方法的具体行为。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Number <span class="keyword">int</span> <span class="comment">// 描述内存格式（但是没有定义内存中的具体数据）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Number)</span> <span class="title">Positive</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span>    <span class="comment">// 定义行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Positiver <span class="keyword">interface</span> &#123;  <span class="comment">// 描述行为</span></span><br><span class="line">    Positive() <span class="keyword">bool</span> <span class="comment">// 定义methods集合，但是没有定义具体行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、interface作用"><a href="#二、interface作用" class="headerlink" title="二、interface作用"></a>二、interface作用</h1><p>描述interface的作用，也即是回答why interface这个问题。</p><p>Francesc给出如下三个理由:</p><ul><li>writing generic algorithm（泛型编程）</li><li>hiding implementation detail （隐藏具体实现）</li><li>providing interception points （dynamic dispatch of calls &amp;&amp; chaining interfaces）</li></ul><p>前两个都很好理解，在这里只说一下最后一点的意思。对于这一点，Francesc给出的例子如下：</p><p>1、 dynamic dispatch of calls</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> headers <span class="keyword">struct</span> &#123;</span><br><span class="line">    rt  http.RoundTripper</span><br><span class="line">    v   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h headers)</span> <span class="title">RoundTrip</span><span class="params">(r *http.Request)</span> *<span class="title">http</span>.<span class="title">Response</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> h.v &#123;</span><br><span class="line">        r.Header.Set(k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h.rt.RoundTrip(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c := &amp;http.Client&#123;</span><br><span class="line">    Transport: headers&#123;</span><br><span class="line">        rt: http.DefaultTransport,</span><br><span class="line">        v:  <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"foo"</span>: <span class="string">"bar"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res, err := c.Get(<span class="string">"http://golang.org"</span>)</span><br></pre></td></tr></table></figure><p>2、 chaining interfaces</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="string">"something base64 code"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r io.Reader = strings.NewReader(input)</span><br><span class="line">r = base64.NewDecoder(base64.StdEncoding, r)</span><br><span class="line">r, err := gzip.NewReader(r)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;log.Fatal(err) &#125;</span><br><span class="line">io.Copy(os.Stdout, r)</span><br></pre></td></tr></table></figure><p>providing interception points 的含义，应该就是，我们对于同一份数据，可能会有不同的处理需求。因此，我们可以定义不同的concrete type，然后实现相同的interface，来在运行时根据需要去进行对应的数据处理。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><p><a href="http://legendtkl.com/2017/06/12/understanding-golang-interface/" target="_blank" rel="noopener">深入理解 Go Interface</a></p></li><li><p><a href="https://speakerdeck.com/campoy/understanding-the-interface" target="_blank" rel="noopener">understanding the interface</a></p></li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/ZChen/category/【golang】类型入门/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZChen"><meta itemprop="description" content="这是一个用于记录我个人学习历程的小站。"><meta itemprop="image" content="/ZChen/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZChen's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/ZChen/category/【golang】类型入门/" class="post-title-link" itemprop="url">【golang】类型转换</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-10 17:04:52" itemprop="dateCreated datePublished" datetime="2019-08-10T17:04:52+08:00">2019-08-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-13 15:17:27" itemprop="dateModified" datetime="2019-10-13T15:17:27+08:00">2019-10-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/ZChen/categories/后端/" itemprop="url" rel="index"><span itemprop="name">后端</span></a></span></span><br></div></header><div class="post-body" itemprop="articleBody"><h1 id="一、类型转换"><a href="#一、类型转换" class="headerlink" title="一、类型转换"></a>一、类型转换</h1><ol><li>语法：&lt;结果类型&gt; := &lt;目标类型&gt;(&lt;表达式&gt;)</li><li>golang自己的基本类型之间的强制转换，我们在这里不讨论。</li><li>类型的强制转换，可以看成编译原理中的类型等价中的名字等价。例如，下面这三种类型是可以相互转换的：</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="keyword">int</span></span><br><span class="line">    j <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="keyword">int</span></span><br><span class="line">    j <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test3 test1</span><br></pre></td></tr></table></figure><p>但是下面这两种类型就不能相互转换了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> test1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    test1J <span class="keyword">int</span></span><br><span class="line">    test1I <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> test2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    i <span class="keyword">int</span></span><br><span class="line">    j <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>类型强制转换是否可以进行，ide是会有提示的。因此类型转换在编译期完成。</li><li>golang不允许隐式类型转换，但是数字转换成表达式中所需类型是可以的。</li><li>还有一些interface间的强制转换，用到的不多，根据IDE提示就可以判断了。</li></ol><h1 id="二、类型断言"><a href="#二、类型断言" class="headerlink" title="二、类型断言"></a>二、类型断言</h1><ol><li>安全类型断言： &lt;目标类型的值&gt;,&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 )</li><li>非安全类型断言：&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )；如果转换错误，则会panic</li><li>类型断言是在运行过程中进行的，因此IDE无法给予提示。</li><li>类型断言只能用于 接口转类型</li></ol></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/ZChen/category/DSY操作手册/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZChen"><meta itemprop="description" content="这是一个用于记录我个人学习历程的小站。"><meta itemprop="image" content="/ZChen/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZChen's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/ZChen/category/DSY操作手册/" class="post-title-link" itemprop="url">DSY操作手册</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-31 02:17:41" itemprop="dateCreated datePublished" datetime="2019-07-31T02:17:41+08:00">2019-07-31</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-13 15:17:27" itemprop="dateModified" datetime="2019-10-13T15:17:27+08:00">2019-10-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/ZChen/categories/杂记/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a></span></span><br></div></header><div class="post-body" itemprop="articleBody"> 又名🐖的护理手册<div class="post-button text-center"> <a class="btn" href="/ZChen/category/DSY操作手册/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/ZChen/category/lucky-day/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZChen"><meta itemprop="description" content="这是一个用于记录我个人学习历程的小站。"><meta itemprop="image" content="/ZChen/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZChen's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/ZChen/category/lucky-day/" class="post-title-link" itemprop="url">lucky day</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-13 11:48:01" itemprop="dateCreated datePublished" datetime="2019-07-13T11:48:01+08:00">2019-07-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-13 15:17:27" itemprop="dateModified" datetime="2019-10-13T15:17:27+08:00">2019-10-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/ZChen/categories/杂记/" itemprop="url" rel="index"><span itemprop="name">杂记</span></a></span></span><br></div></header><div class="post-body" itemprop="articleBody"> 最为幸运的一天<div class="post-button text-center"> <a class="btn" href="/ZChen/category/lucky-day/#more" rel="contents">阅读全文 &raquo;</a></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/ZChen/category/个人博客搭建/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ZChen"><meta itemprop="description" content="这是一个用于记录我个人学习历程的小站。"><meta itemprop="image" content="/ZChen/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ZChen's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> <a href="/ZChen/category/个人博客搭建/" class="post-title-link" itemprop="url">个人博客搭建</a></h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-10 00:01:51" itemprop="dateCreated datePublished" datetime="2019-07-10T00:01:51+08:00">2019-07-10</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-10-13 15:17:27" itemprop="dateModified" datetime="2019-10-13T15:17:27+08:00">2019-10-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/ZChen/categories/工具-环境/" itemprop="url" rel="index"><span itemprop="name">工具&环境</span></a></span></span><br></div></header><div class="post-body" itemprop="articleBody"><h1 id="个人博客搭建"><a href="#个人博客搭建" class="headerlink" title="个人博客搭建"></a>个人博客搭建</h1><p>本文将会介绍从购买完一个云服务器，到搭建完成个人博客的全部历程。</p><h2 id="搭建node-js环境"><a href="#搭建node-js环境" class="headerlink" title="搭建node.js环境"></a>搭建node.js环境</h2><p>本部分参考<a href="https://cloud.tencent.com/developer/labs/lab/10040" target="_blank" rel="noopener">腾讯云 搭建node.js环境</a></p><h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p>下载最新稳定版node.js(自己去官网找Linux上的最新版node.js连接)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v6.10.3/node-v6.10.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>下载完成后，将其解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvJf node-v6.10.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><p>将解压的 Node.js 目录移动到 /usr/local 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv node-v6.10.3-linux-x64 /usr/local/node-v6</span><br></pre></td></tr></table></figure><p>配置 node 软链接到 /bin 目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/node-v6/bin/node /bin/node</span><br></pre></td></tr></table></figure><p>用node -v命令来查看是否安装成功</p><h3 id="配置npm"><a href="#配置npm" class="headerlink" title="配置npm"></a>配置npm</h3><p>npm 是 Node.js 的包管理和分发工具。它可以让 Node.js 开发者能够更加轻松的共享代码和共用代码片段</p><p>下载 node 的压缩包中已经包含了 npm , 我们只需要将其软链接到 bin 目录下即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/node-v6/bin/npm /bin/npm</span><br></pre></td></tr></table></figure><p>配置环境变量</p><p>将 /usr/local/node-v6/bin 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具(如果你之前自己改过目录名，按照自己的目录名来)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;export PATH=/usr/local/node-v6/bin:$PATH&apos; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure><p>生效环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>此处建议安装forever，未来会用得上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install forever -g</span><br></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>略</p><h2 id="hexo环境搭建"><a href="#hexo环境搭建" class="headerlink" title="hexo环境搭建"></a>hexo环境搭建</h2><p>本部分参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>上述过程正确进行的话，只需以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>用 hexo -v命令查看是否成功，如果没有成功，但是npm -v成功，则可能上面配置环境变量步骤有误。</p><h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>在你想建站的文件夹下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>此时你在访问你服务器IP地址的4000端口就可以看到一个基础的博客页面了。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><div class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/ZChen/images/avatar.png" alt="ZChen"><p class="site-author-name" itemprop="name">ZChen</p><div class="site-description motion-element" itemprop="description">这是一个用于记录我个人学习历程的小站。</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/ZChen/archives/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/ZChen/categories/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/ZChen/tags/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/chendante" title="GitHub &rarr; https://github.com/chendante" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">ZChen</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.2.0</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/ZChen/lib/jquery/index.js?v=3.4.1"></script><script src="/ZChen/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/ZChen/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/ZChen/js/utils.js?v=7.2.0"></script><script src="/ZChen/js/motion.js?v=7.2.0"></script><script src="/ZChen/js/schemes/muse.js?v=7.2.0"></script><script src="/ZChen/js/next-boot.js?v=7.2.0"></script></body></html>